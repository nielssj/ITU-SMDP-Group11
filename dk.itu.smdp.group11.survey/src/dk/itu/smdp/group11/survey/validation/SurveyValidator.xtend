/*
 * generated by Xtext
 */
package dk.itu.smdp.group11.survey.validation

import group11survey.Answer
import group11survey.Group11surveyPackage
import group11survey.Question
import group11survey.Survey
import group11survey.TableQuestion
import java.util.List
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SurveyValidator extends AbstractSurveyValidator {
	public static val SurveyHasQuestion = "dk.itu.smdp.group11.survey.SurveyHasQuestion"
	public static val QuestionHasAnswer = "dk.itu.smdp.group11.survey.QuestionHasAnswer"
	public static val ReferenceIsCorrect = "dk.itu.smdp.group11.survey.ReferenceIsCorrect"
	public static val QuestionHasUniqueName = "dk.itu.smdp.group11.survey.QuestionHasUniqueName"
	public static val ExclusiveQuestionHasMultipleAnswers = "dk.itu.smdp.group11.survey.ExclusiveQuestionHasMultipleAnswers"
	public static val TableQuestionHasNoFollowups = "dk.itu.smdp.group11.survey.TableQuestionHasNoFollowups"
	public static val NoCycles = "dk.itu.smdp.group11.survey.NoCycles"
	public static val QuestionHasName = "dk.itu.smdp.group11.survey.QuestionHasName"
	public static val QuestionBodyNotEmpty = "dk.itu.smdp.group11.survey.QuestionBodyNotEmpty"

	@Check
	def checkSurveyHasQuestion(Survey survey) {
		if (survey.questions.size < 1) {
			error('Survey must have at least one question', Group11surveyPackage.Literals.SURVEY__QUESTIONS, 
				SurveyHasQuestion)
		}
	}
	
	@Check
	def checkQuestionHasAnswer(Question question) {
		if (question.answers.size < 1) {
			error('Question must have at least one answer', Group11surveyPackage.Literals.QUESTION__ANSWERS,
				QuestionHasAnswer)
		}
	}
	
	@Check
	def checkQuestionBodyNotEmpty(Question question) {
		if (question.body == null || question.body.trim.length < 1) {
			error('Question can not be empty', Group11surveyPackage.Literals.QUESTION__BODY, QuestionBodyNotEmpty)
		}
	}
	
	@Check
	def checkQuestionHasName(Question question) {
		if (question.name == null || question.name.trim.length < 1) {
			error('Question ID can not be empty', Group11surveyPackage.Literals.QUESTION__NAME, QuestionHasName)
		}
	}
	
	List<String> list
	@Check
	def checkQuestionHasUniqueName(Question question) {
		list = newArrayList()
		{(question.eContainer as Survey).questions}.forEach[list.add(name)]
		list.remove(question.name)
		if (list.contains(question.name)) {
			error('Question IDs must be unique', Group11surveyPackage.Literals.QUESTION__NAME, QuestionHasUniqueName)
		}
	}
	
	@Check 
	def checkExclusiveQuestionHasMultipleAnswers(Question question) {
		if (question.isExclusive && question.answers.size < 2) {
			error('Exclusive question must have at least two answers', Group11surveyPackage.Literals.QUESTION__IS_EXCLUSIVE, 
				ExclusiveQuestionHasMultipleAnswers)
		}
	}
	
	@Check
	def checkTableQuestionHasNoFollowups(Answer answer) {
		if ((answer.eContainer as Question) instanceof TableQuestion) {
			if (!(answer.followup.size == 0)) {
				error('Table question answers can not have followup questions', Group11surveyPackage.Literals.ANSWER__FOLLOWUP,
					TableQuestionHasNoFollowups)
			}
		}
	}
	
	@Check
	def checkReferenceIsCorrect(Answer answer) {
		survey = (answer.eContainer as Question).eContainer as Survey
		
		for (Question followupQuestion : answer.followup) {
			if (!survey.questions.contains(followupQuestion)) {
				error('Reference to undefined question', Group11surveyPackage.Literals.ANSWER__FOLLOWUP, 
					ReferenceIsCorrect)	
			}
		}
	}
	
	Survey survey
	Question currentQuestion
	@Check
	def checkNoCycles(Answer answer) {
		survey = (answer.eContainer as Question).eContainer as Survey
		currentQuestion = answer.eContainer as Question
		
		for (Answer currentQuestionAnswer : currentQuestion.answers) {
			for (Question currentAnswerFollowup : answer.followup) {
				for (Question nextQuestion : survey.questions) {
					if (currentAnswerFollowup.name.equals(nextQuestion.name)) {
						for (Answer nextQuestionAnswer : nextQuestion.answers) {
							if (nextQuestionAnswer.followup.contains(currentQuestion)) {
								error('Cycle detected', Group11surveyPackage.Literals.ANSWER__FOLLOWUP, NoCycles)
							}
						}
					}
				}
			}
		}
	}
	
	@Check
	def checkQuestionOrder(Answer answer) {
		survey = (answer.eContainer as Question).eContainer as Survey
		currentQuestion = answer.eContainer as Question
		
		for (Question followupQuestion : answer.followup) {
			if (survey.questions.indexOf(followupQuestion) < survey.questions.indexOf(currentQuestion)) {
				warning('The order of your defined questions is not guaranteed, since you referenced a higher order question in a lower order question.', Group11surveyPackage.Literals.ANSWER__FOLLOWUP)
			}
		}
	}
}